<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[水止君]]></title>
  <link href="platojobs.cn/atom.xml" rel="self"/>
  <link href="platojobs.cn/"/>
  <updated>2024-07-24T18:07:53+08:00</updated>
  <id>platojobs.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[isa指针]]></title>
    <link href="platojobs.cn/17218116364930.html"/>
    <updated>2024-07-24T17:00:36+08:00</updated>
    <id>platojobs.cn/17218116364930.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<p><code>isa</code>是一个<code>Class类型</code>的指针，其源码结构为<code>isa_t</code>联合体，在类中以Class对象存在，指向类的地址，大小为8字节(64位)。</p>
</li>
<li>
<p>每个实例对象都有<code>isa</code>的指针指向对象的类。<code>Class</code>里也有个<code>isa</code>的指针指向<code>meteClass</code>(元类)。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。元类（meteClass）也是类，它也是对象，也有isa指针。</p>
</li>
</ul>
<p><strong>isa的指向</strong>：对象的<code>isa</code>指向类，类的<code>isa</code>指向元类(meta class)，元类<code>isa</code>指向根元类，根元类的<code>isa</code>指向本身，形成了一个封闭的内循环。isa可以帮助一个对象找到它的方法。</p>
<p><strong>isa指向图中类的继承关系</strong>：<code>LGTeacher -&gt; LGPerson -&gt; NSObject -&gt; nil</code>。这里需要注意的是根元类的父类是 <code>NSObject</code>，<code>NSObject</code>的父类是<code>nil</code>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[runtime]]></title>
    <link href="platojobs.cn/17218116241379.html"/>
    <updated>2024-07-24T17:00:24+08:00</updated>
    <id>platojobs.cn/17218116241379.html</id>
    <content type="html"><![CDATA[
<p><strong>什么是runtime？</strong></p>
<p>runtime 一套c、c++、汇编编写的API，为OC提供运行时功能。能够将数据类型的确定由编译期推迟到运行时。</p>
<p><strong>问1：方法的本质，问2：runtime的消息机制</strong></p>
<p><strong>方法的本质其实就是发送消息</strong>。</p>
<p>发送消息主要流程：</p>
<ul>
<li>
<ol>
<li>快速查找：<code>objc_msgSend</code>查找<code>cache_t</code>缓存消息</li>
</ol>
</li>
<li>
<ol start="2">
<li>慢速查找：递归自己和父类查找方法<code>lookUpImpOrForward</code></li>
</ol>
</li>
<li>
<ol start="3">
<li>查找不到消息，进行动态方法解析：<code>resolveInstanceMethod</code></li>
</ol>
</li>
<li>
<ol start="4">
<li>消息快速转发：<code>forwardingTargetForSelector</code></li>
</ol>
</li>
<li>
<ol start="5">
<li>消息慢速转发：消息签名<code>methodSignatureForSelector</code>和分发<code>forwardInvocation</code></li>
</ol>
</li>
<li>
<ol start="6">
<li>最终仍未找到消息：程序crash，报经典错误信息<code>unrecognized selector sent to instance xxx</code></li>
</ol>
</li>
</ul>
<p><strong>SEL是什么？IMP是什么？两者有什么联系？</strong></p>
<ul>
<li>
<p><code>SEL</code>是方法编号，即方法名称，在dyld加载镜像时，通过read_image方法加载到内存的表中了。</p>
</li>
<li>
<p><code>IMP</code>是函数实现指针，找IMP就是找函数的过程</p>
</li>
<li>
<p><strong>两者的关系：</strong><code>sel</code>相当于书本的目录标题，<code>imp</code>就是书本的页码。查找具体的函数就是想看这本书里面具体篇章的内容：</p>
<ul>
<li>
<p>1). 我们首先知道想看什么，也就是title -sel</p>
</li>
<li>
<p>2). 然后根据目录对应的页码 -imp</p>
</li>
<li>
<p>3). 打开具体的内容 -方法的具体实现</p>
</li>
</ul>
</li>
</ul>
<p><strong>runtime应用：</strong></p>
<ul>
<li>
<p>1.方法的交换：具体应用拦截系统自带的方法调用（Method Swizzling黑魔法）</p>
</li>
<li>
<p>2.实现给分类增加属性</p>
</li>
<li>
<p>3.实现字典的模型和自动转换</p>
</li>
<li>
<p>4.JSPatch替换已有的OC方法实行等</p>
</li>
<li>
<p>5.aspect 切面编程</p>
</li>
</ul>
<p><strong>能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</strong></p>
<ul>
<li>
<p>1.不能向编译后得到的类中增加实例变量。</p>
</li>
<li>
<p>2.可以向运行时创建的类中添加实例变量。</p>
</li>
<li>
<p>3.因为编译后的类已经注册在 runtime 中，类结构体中的 <code>objc_ivar_list</code><strong>实例变量的链表</strong>和 <code>instance_size</code> <strong>实例变量的内存大小</strong>已经确定，同时<code>runtime</code>会调用 <code>class_setIvarLayout</code>或<code>class_setWeakIvarLayout</code>来处理 <code>strong</code>、<code>weak</code>引用，所以不能向存在的类中添加实例变量。</p>
</li>
</ul>
<p>运行时创建的类是<strong>可以添加实例变量</strong>，调用<code>class_addIvar</code>函数。但是得在调用<code>objc_allocateClassPair</code>之后，<code>objc_registerClassPair</code>之前，原因同上。</p>
<p><strong>Category中添加属性和成员变量的区别</strong></p>
<ul>
<li>
<ol>
<li><code>Category</code>它的主要作用是在不改变原有类的前提下，动态地给这个类添加一些方法。</li>
</ol>
</li>
<li>
<ol start="2">
<li>分类的结构体指针中，没有属性列表，只有方法列表。原则上它只能添加方法，不能添加属性(成员变量)，但是可以借助运行时关联对象<code>objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</code>、<code>objc_getAssociatedObject(self,@selector(name));</code>。</li>
</ol>
</li>
<li>
<ol start="3">
<li>分类中的可以写<code>@property</code>，但不会生成setter/getter方法声明和实现，也不会生成私有的成员变量，会编译通过，但是引用变量会报错。</li>
</ol>
</li>
<li>
<ol start="4">
<li>如果分类中有和原有类同名的方法，会优先调用分类中的方法，就是说会忽略原有类的方法，同名方法调用的优先级为 分类 本类 父类，因为方法是放在方法栈中，遵循先进后出原则；</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[runloop]]></title>
    <link href="platojobs.cn/17218115915749.html"/>
    <updated>2024-07-24T16:59:51+08:00</updated>
    <id>platojobs.cn/17218115915749.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><code>runloop</code>：通过系统内部维护的循环进行事件/消息管理的一个对象。runloop实际上就是一个<code>do...while</code>循环，有任务时开始，无任务时休眠。</p>
</blockquote>
<p><strong>其本质是通过<code>mach_msg()</code>函数接收、发送消息。</strong></p>
<p><strong>RunLoop 与线程的关系：</strong></p>
<ul>
<li>
<ol>
<li><code>RunLoop</code>的作用就是来管理线程的，当线程的<code>RunLoop</code>开启后，线程就会在执行完任务后，处于休眠状态，随时等待接受新的任务，不会退出。</li>
</ol>
</li>
<li>
<ol start="2">
<li>只有主线程的<code>RunLoop</code>是默认开启的，其他线程的<code>RunLoop</code>需要手动开启。所以当程序开启后，主线程会一直运行，不会退出。</li>
</ol>
</li>
</ul>
<p><strong>runloop 事件循环机制内部流程</strong></p>
<p><img src="media/17218115915749/17218116018899.png" alt="" /></p>
<p><strong>RunLoop主要涉及五个类：</strong></p>
<p><code>CFRunLoop</code>：RunLoop对象、</p>
<p><code>CFRunLoopMode</code>：五种RunLoop运行模式、</p>
<p><code>CFRunLoopSource</code>：输入源/事件源，包括<code>Source0</code> 和 <code>Source1</code></p>
<p><code>CFRunLoopTimer</code>：定时源，就是NSTimer、</p>
<p><code>CFRunLoopObserver</code>：观察者，用来监听RunLoop。</p>
<ul>
<li>
<ol>
<li><code>CFRunLoop</code>：<strong>RunLoop对象</strong></li>
</ol>
</li>
<li>
<ol start="2">
<li><code>CFRunLoopMode</code>：<strong>RunLoop运行模式，有五种：</strong></li>
</ol>
<ul>
<li>
<p><code>kCFRunLoopDefaultMode</code>：默认的运行模式，通常主线程是在这个 Mode 下运行的。</p>
</li>
<li>
<p><code>UITrackingRunLoopMode</code>：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p>
</li>
<li>
<p><code>UIInitializationRunLoopMode</code>：在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p>
</li>
<li>
<p><code>GSEventReceiveRunLoopMode</code>：接受系统事件的内部 Mode，通常用不到。</p>
</li>
<li>
<p><code>kCFRunLoopCommonModes</code>：是一个伪模式，可以在标记为CommonModes的模式下运行，RunLoop会自动将<code>_commonModeItems</code>里的 <code>Source</code>、<code>Observer</code>、<code>Timer</code> 同步到具有此标记的Mode里。</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>
<p><code>CFRunLoopSource</code>：<strong>输入源/事件源，包括Source0 和 Source1两种：</strong></p>
<ul>
<li>
<p><code>Source1</code>：基于mach_Port，处理来自系统内核或其它进程的事件，比如点击手机屏幕。</p>
</li>
<li>
<p><code>Source0 </code>：非基于Port的处理事件，也就是应用层事件，需要手动标记为待处理和手动唤醒RunLoop。</p>
</li>
<li>
<p>简单举例：一个APP在前台静止，用户点击APP界面，屏幕表面的事件会先包装成<code>Event</code>告诉<code>source1(mach_port)</code>，<code>source1</code>唤醒<code>RunLoop</code>将事件<code>Event</code>分发给<code>source0</code>，由<code>source0</code>来处理。</p>
</li>
</ul>
</li>
<li>
<p><code>CFRunLoopTimer</code>：<strong>定时源</strong>，就是NSTimer。在预设的时间点唤醒RunLoop执行回调。因为它是基于RunLoop的，因此它不是实时的（就是NSTimer 是不准确的。 因为RunLoop只负责分发源的消息。如果线程当前正在处理繁重的任务，就有可能导致Timer本次延时，或者少执行一次）。</p>
</li>
<li>
<p><code>CFRunLoopObserver</code>：<strong>观察者，用来监听以下时间点：CFRunLoopActivity</strong></p>
<ul>
<li>
<p><code>kCFRunLoopEntry</code>：RunLoop准备启动</p>
</li>
<li>
<p><code>kCFRunLoopBeforeTimers</code>：RunLoop将要处理一些Timer相关事件</p>
</li>
<li>
<p><code>kCFRunLoopBeforeSources</code>：RunLoop将要处理一些Source事件</p>
</li>
<li>
<p><code>kCFRunLoopBeforeWaiting</code>：RunLoop将要进行休眠状态,即将由用户态切换到内核态</p>
</li>
<li>
<p><code>kCFRunLoopAfterWaiting</code>：RunLoop被唤醒，即从内核态切换到用户态后</p>
</li>
<li>
<p><code>kCFRunLoopExit</code>：RunLoop退出</p>
</li>
<li>
<p><code>kCFRunLoopAllActivities</code>：监听所有状态</p>
</li>
</ul>
</li>
</ol>
<p><strong>各数据结构之间的联系：</strong></p>
<ul>
<li>
<p>1：<code>Runloop</code>和<code>线程</code>是<strong>一对一</strong>的关系</p>
</li>
<li>
<p>2：<code>Runloop</code>和<code>RunloopMode</code>是<strong>一对多</strong>的关系</p>
</li>
<li>
<p>3：<code>RunloopMode</code>和<code>RunloopSource</code>是<strong>一对多</strong>的关系</p>
</li>
<li>
<p>4：<code>RunloopMode</code>和<code>RunloopTimer</code>是<strong>一对多</strong>的关系</p>
</li>
<li>
<p>5：<code>RunloopMode</code>和<code>RunloopObserver</code>是<strong>一对多</strong>的关系</p>
</li>
</ul>
<p><strong>为什么 main 函数能够保持一直存在且不退出？</strong></p>
<blockquote>
<p>在 main 函数内部会调用 <code>UIApplicationMain</code> 这样一个函数，而在<code>UIApplicationMain</code>内部会启动主线程的 <code>runloop</code>，可以做到有消息处理时，能够迅速从<strong>内核态到用户态</strong>的切换，立刻唤醒处理，而没有消息处理时通过<strong>用户态到内核态</strong>的切换进入等待状态，<strong>避免资源占用</strong>。<strong>因此 main 函数能够一直存在且不退出</strong>。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[事件传递和响应机制]]></title>
    <link href="platojobs.cn/17218115735673.html"/>
    <updated>2024-07-24T16:59:33+08:00</updated>
    <id>platojobs.cn/17218115735673.html</id>
    <content type="html"><![CDATA[
<p>在iOS中只有继承了<code>UIResponder</code>的对象才能接受并处理事件。</p>
<p><strong>事件传递</strong>：事件的传递是从上到下（父控件到子控件）</p>
<ul>
<li>
<p>产生触摸事件A后，触摸事件会被添加到由<code>UIApplication</code>管理的事件队列中(首先接收到事件的是UIApplication)。</p>
</li>
<li>
<p><code>UIApplication</code>会从事件队列中取出最前面的事件(此处假设为触摸事件A)，将<strong>事件对象由上往下传递</strong>(<code>UIApplication</code>-<code>keyWindow</code>-父控件-子控件)，查找最合适的控件处理事件</p>
</li>
<li>
<p>只要事件传递给控件，就会调用自身的<code>hitTest:withEvent:</code>方法，寻找能够响应事件最合适的view(其内部会调用<code>pointInside:withEvent:</code>判断触摸点是否在自己身上)。</p>
</li>
</ul>
<p><strong>响应机制</strong>：从下到上（顺着响应者链条向上传递：子控件到父控件)<br />
当事件传递到某个控件，但是最终<code>hitTest:withEvent:</code>没有找到第一响应者，那么该事件会沿着响应者链向上回溯，如果<code>UIWindow实例</code>和<code>UIApplication实例</code>都不能处理该事件，则该事件会被丢弃。</p>
<p>**响应者链条：**在iOS程序中视图的摆放是有前后关系的，一个控件可以放到另一个控件上面或下面，那么用户点击某个控件时是触发上面的控件还是下面的控件呢，这种先后关系构成一个链条就叫响应者链。也可以说，<strong>响应者链是由多个响应者对象连接起来的链条</strong>。</p>
<ul>
<li>
<p>如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件</p>
</li>
<li>
<p><strong>UIView有三种情况不能接收事件：</strong></p>
<ul>
<li>
<p>不接收用户交互：<code>userInteractionEnabled = NO</code></p>
</li>
<li>
<p>隐藏：<code>hidden = YES</code></p>
</li>
<li>
<p>透明：<code>alpha&lt;0.01</code></p>
</li>
</ul>
</li>
</ul>
<p><strong>子视图在父视图之外区域点击是否有效？</strong></p>
<ul>
<li>
<p>无效**(父视图的clipsToBounds=NO，这样超过父视图bound区域的子视图内容也会显示)，<strong>因为父视图的<code>pointInside:withEvent:</code>方法会返回NO，就不会向下遍历子视图了。</strong></p>
</li>
<li>
<p>但是可以通过重写<code>pointInside:withEvent:</code>来处理。</p>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebSocket与TCP Socket的区别]]></title>
    <link href="platojobs.cn/17218115565113.html"/>
    <updated>2024-07-24T16:59:16+08:00</updated>
    <id>platojobs.cn/17218115565113.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<p><code>Socket</code>是抽象层，并不是一个协议，是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输层(TCP/UDP)之间的一组接口。</p>
</li>
<li>
<p><code>WebSocket</code>和HTTP一样，都是应用层协议，是基于TCP 连接实现的双向通信协议，替代<code>HTTP轮询</code>的一种技术方案。是全双工通信协议，<code>HTTP</code>是单向的，注意WebSocket和Socket是完全不同的两个概念。</p>
<ul>
<li>
<p><code>WebSocket</code>建立连接时通过HTTP传输，但是建立之后，在真正传输时候是不需要HTTP协议的。</p>
</li>
<li>
<p>相对于传统 <code>HTTP</code> 每次请求-应答都需要客户端与服务端建立连接的模式，<code>WebSocket</code> 是类似 <code>Socket</code> 的 <code>TCP 长连接</code>的通讯模式，一旦 <code>WebSocket</code> 连接建立后，后续数据都以帧序列的形式传输。在客户端断开 <code>WebSocket</code> 连接或 <code>Server</code> 端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p>
</li>
<li>
<p><code>WebSocket</code>连接过程 —— 握手过程</p>
<ul>
<li>
<p>1.浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。</p>
</li>
<li>
<p>2.TCP连接成功后，浏览器通过HTTP协议向服务器传送<code>WebSocket</code>支持的版本号等信息。（开始前的HTTP握手）</p>
</li>
<li>
<p>3.服务器收到客户端的握手请求后，同样采用<code>HTTP</code>协议回馈数据。</p>
</li>
<li>
<p>4.当收到了连接成功的消息后，通过<code>TCP</code>通道进行传输通信。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Socket.IO</code> 是一个为浏览器（客户端）和服务器之间提供实时，双向和基于事件的通信软件库。</p>
</li>
</ul>
<p><code>Socket.IO</code> 是把数据传输抽离成 Engine.IO，内部对轮询（Polling）和 WebSocket 等进行了封装，抹平一些细节和平台兼容的问题，提供统一的 API。</p>
<blockquote>
<p>注意 <code>Socket.IO</code> 不是 <code>WebSocket</code> 的实现，只是在必要时使用 <code>WebSocket</code> 传输数据，并在此基础上会加一些 <code>MetaData</code>。这就是为什么 <code>WebSocket</code> 的客户端/服务器 无法和 <code>Socket.IO</code> 的服务器/客户端进行通信。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTPS的加密原理]]></title>
    <link href="platojobs.cn/17218115416529.html"/>
    <updated>2024-07-24T16:59:01+08:00</updated>
    <id>platojobs.cn/17218115416529.html</id>
    <content type="html"><![CDATA[
<p><code>HTTPS</code>是身披<code>SSL</code>外壳的<code>HTTP</code>，是一种通过计算机网络进行安全通信的传输协议，经由<code>HTTP</code>进行通信，利用<code>SSL/TLS</code>建立安全信道，加密数据包。</p>
<ul>
<li>
<ol>
<li><strong>客户端向服务端发送请求<a href="https://baidu.com/">https://baidu.com</a>，然后连接到server的443端口</strong></li>
</ol>
</li>
<li>
<ol start="2">
<li><strong>服务端本身是要有一套数字证书的，这套证书其实就是一对公钥和私钥</strong></li>
</ol>
</li>
</ul>
<blockquote>
<p>服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。</p>
</blockquote>
<ul>
<li>
<ol start="3">
<li><strong>服务端把证书(公钥)传送给客户端</strong><br />
这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。</li>
</ol>
</li>
<li>
<ol start="4">
<li><strong>客户端解析证书，验证无误后用证书加密一个随机生成的值(秘钥)</strong><br />
这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（秘钥）。然后用证书对该随机值进行加密。</li>
</ol>
</li>
<li>
<ol start="5">
<li><strong>客户端传送加密后的秘钥给服务端</strong><br />
这部分传送的是用证书加密后的秘钥，目的就是让服务端得到这个秘钥，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li>
</ol>
</li>
<li>
<ol start="6">
<li><strong>服务端用私钥解密随机值，然后通过该值对称加密信息</strong><br />
服务端用私钥解密秘钥，得到了客户端传过来的私钥，然后把内容通过该值进行对称加密。</li>
</ol>
</li>
<li>
<ol start="7">
<li><strong>再传输加密后的信息给客户端</strong><br />
这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。</li>
</ol>
</li>
<li>
<ol start="8">
<li><strong>因为是对称加密，客户端可以解密信息</strong><br />
客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容。</li>
</ol>
</li>
</ul>
<p><strong>HTTP和HTTPS的区别？</strong></p>
<ul>
<li>
<p><code>https</code>协议需要到ca申请证书，一般免费证书很少，需要交费。</p>
</li>
<li>
<p><code>http</code>是超文本传输协议，信息是明文传输，<code>https</code> 则是具有安全性的ssl加密传输协议。</p>
</li>
<li>
<p><code>http</code>和<code>https</code>使用的是完全不同的连接方式用的端口也不一样，前者是80，后者是443。</p>
</li>
<li>
<p><code>http</code>的连接很简单，是无状态的。</p>
</li>
<li>
<p><code>HTTPS</code>协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全</p>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络TCP协议，三次握手]]></title>
    <link href="platojobs.cn/17218115221533.html"/>
    <updated>2024-07-24T16:58:42+08:00</updated>
    <id>platojobs.cn/17218115221533.html</id>
    <content type="html"><![CDATA[
<p><code>TCP</code>是传输控制协议，具有面向连接、可靠传输、点到点通信、全双工服务等特点，TCP侧重可靠传输。<br />
<code>UDP</code>是用户数据报协议，具有非连接的、不可靠的、点到多点的通信等特点，UDP侧重快速传输。</p>
<p><strong>TCP/IP协议：</strong><code>TCP/IP</code>不是一个协议，而是一个协议簇的统称。通常使用的网络是在TCP/IP协议簇的基础上运行的。<strong>应用层</strong>的<code>HTTP</code>、<code>DNS</code>、<code>FTP</code>，<strong>传输层</strong>的<code>TCP</code>(传输控制协议)、<code>UDP</code>(用户数据报协议)，<strong>网络层</strong>的<code>IP</code>等等都属于它内部的一个子集。</p>
<p><strong>TCP报文重点字段：</strong><br />
<code>序号</code>：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。<br />
<code>确认序号</code>：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。<br />
<code>标志位</code>：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p>
<ul>
<li>（A）<code>URG</code>：紧急指针（urgent pointer）有效。</li>
<li>（B）<code>ACK</code>：确认序号有效。</li>
<li>（C）<code>PSH</code>：接收方应该尽快将这个报文交给应用层。</li>
<li>（D）<code>RST</code>：重置连接。</li>
<li>（E）<code>SYN</code>：发起一个新连接。</li>
<li>（F）<code>FIN</code>：释放一个连接。</li>
</ul>
<p>TCP是面向连接的协议，建立连接需要经过**<code>三次握手</code>：**</p>
<ul>
<li>
<p>1.首先客户端将<code>标志位SYN置为1</code>，然后随机产生一个<code>序号seq=J</code>，将数据包发送给服务端，客户端进入<code>SYN_SENT</code>状态，等待服务端确认。</p>
</li>
<li>
<p>2.服务器收到数据包后由<code>标志位SYN=1</code>知道Client请求建立连接，Server将<code>标志位SYN和ACK都置为1</code>，<code>确认序号ack=J+1</code>，随机产生一个<code>序号seq=K</code>，并将该数据包发送给服务端确认连接请求，服务端进入<code>SYN_RCVD</code>状态。</p>
</li>
<li>
<p>3.客户端收到确认后，检查<code>确认序号ack是否为J+1</code>，<code>标志位ACK是否为1</code>，确认正确后将<code>标志位ACK=1</code>和<code>确认序号ack=K+1</code>数据包发送给服务端，服务端检查<code>标志位ACK为1</code>、<code>确认序号ack=K+1</code>成功后，客户端和服务端进入<code>ESTABLISHED</code>(建立连接)状态，完成三次握手，两端可以进行数据传输。</p>
</li>
</ul>
<p>TCP断开连接需要经过**<code>四次挥手</code>：**</p>
<ul>
<li>
<p>1.首先客户端向服务端发送<code>释放连接的标志位 FIN</code>，客户端进入<code>FIN_WAIT_1</code>状态，等待服务端确认。</p>
</li>
<li>
<p>2.服务端收到<code>标志位FIN</code>后发送<code>确认标志位ACK</code>给客户端，确认序号为<code>收到序号+1</code>(与SYN相同，一个FIN占用一个序号)，服务端进入<code>CLOSE_WAIT</code>状态。</p>
</li>
<li>
<p>3.服务端发送自己的<code>释放连接的标志位 FIN</code>。服务端进入<code>LAST_ACK</code>状态。</p>
</li>
<li>
<p>4.客户端收到<code>标志位FIN</code>后进入<code>TIME_WAIT</code>状态，然后发送一个<code>确认标志位ACK</code>给服务端，确认序号为<code>收到序号+1</code>，服务端进入<code>CLOSED</code>状态，完成四次挥手。</p>
</li>
</ul>
<p>**客户端进入<code>TIME_WAIT</code>状态而不是直接进入<code>CLOSED</code>状态是因为：**我们必须要假想网络是不可靠的，你无法保证你最后发送的<code>ACK报文</code>一定会被对方收到，因此对方处于<code>LAST_ACK</code>状态下的<code>SOCKET</code>可能会因为超时未收到<code>ACK</code>报文，而重发FIN报文，所以这个<code>TIME_WAIT</code>状态的作用就是用来重发可能丢失的<code>ACK</code>报文。</p>
<p><strong>为什么不能用两次握手进行连接？</strong></p>
<blockquote>
<p>因为三次握手是为了双方都知道彼此已做好准备，如果改成两次握手，会发生死锁。假设客户端给服务端发送连接请求，服务端收到后发送确认连接给客户端，如果两次握手的话此时服务端会认为已经建立了连接，可以发送数据了，但是如果确认连接数据丢失，客户端还不知道已经建立了连接，会一直等待确认连接序号，导致数据传输超时，服务端重复发送同样的数据，造成死锁。</p>
</blockquote>
<p><strong>为什么是四次挥手而不是三次？</strong></p>
<p>因为TCP是全双工连接，关闭连接需要双向确认关闭才算是真正的关闭，否则未关闭一方仍可以继续发送数据。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通知，能不能跨线程]]></title>
    <link href="platojobs.cn/17218115035392.html"/>
    <updated>2024-07-24T16:58:23+08:00</updated>
    <id>platojobs.cn/17218115035392.html</id>
    <content type="html"><![CDATA[
<p>不能跨线程，在哪个线程发送的通知，就会在哪个线程接收。所以需要手动切换到主线程更新UI。</p>
<ul>
<li>**测试过程：**发出通知的线程决定接收通知处理代码线程</li>
</ul>
<p><strong>主线程</strong>发通知 — <strong>子线程</strong>监听通知：接收通知代码在主线程处理</p>
<p><strong>子线程</strong>发通知 — <strong>主线程</strong>监听通知：接收通知代码在子线程处理</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程和锁]]></title>
    <link href="platojobs.cn/17218114899665.html"/>
    <updated>2024-07-24T16:58:09+08:00</updated>
    <id>platojobs.cn/17218114899665.html</id>
    <content type="html"><![CDATA[
<p>**进程：**是资源分配的基本单位，它是程序执行时的一个实例，在程序运行时创建。</p>
<p>**线程：**是程序执行的最小单位，是进程的一个执行流，一个进程由多个线程组成。</p>
<p><strong>多线程：</strong></p>
<p>一个进程中并发执行多个线程，叫做<strong>多线程</strong>。在一个时间片内，CPU只能<strong>处理一个线程中的一个任务</strong>，对于一个单核CPU来说，在不同的时间片来执行不同线程中的任务，就形成了多个任务在同时执行的“假象”。</p>
<p><strong>多线程的几种方式：</strong></p>
<ul>
<li>
<ol>
<li><code>pthread</code>：即<code>POSIX Thread</code>，缩写称为<code>pthread</code>，是线程的POSIX标准，<strong>是一套通用的多线程API</strong>，<strong>可以</strong>在<code>Unix/Linux/Windows</code>等平台<strong>跨平台使用</strong>。iOS中基本不使用。</li>
</ol>
</li>
<li>
<ol start="2">
<li><code>NSThread</code>：<strong>苹果封装的面向对象的线程类，可以直接操作线程</strong>，比起<code>GCD</code>，<code>NSThread</code>效率更高，<strong>由程序员自行创建</strong>，当线程中的任务执行完毕后，线程会自动退出，<strong>程序员也可手动管理线程的生命周期</strong>。使用频率较低。</li>
</ol>
</li>
<li>
<ol start="3">
<li><code>GCD</code>：全称<code>Grand Central Dispatch</code>，<strong>由C语言实现，是苹果为多核并行运算提出的解决方案</strong>，CGD会自动利用更多的CPU内核，<strong>自动管理线程的生命周期</strong>，程序员只需要告诉GCD需要执行的任务，<strong>无需编写任何管理线程的代码</strong>。GCD也是iOS使用频率最高的多线程技术。</li>
</ol>
</li>
<li>
<ol start="4">
<li><code>NSOperation</code>：<strong>基于GCD封装的面向对象的多线程技术，常配合NSOperationQueue使用</strong>，使用频率较高。</li>
</ol>
</li>
</ul>
<p><strong>GCD和NSOperation区别</strong></p>
<ul>
<li>
<ol>
<li><code>GCD</code>仅仅支持<code>先进先出FIFO队列</code>，不支持异步操作之间的依赖关系设置。而<code>NSOperation</code>中的队列可以被重新设置优先级，从而实现不同操作的执行顺序调整。</li>
</ol>
</li>
<li>
<ol start="2">
<li><code>NSOperation</code>支持<code>KVO</code>，可以观察任务的执行状态。</li>
</ol>
</li>
<li>
<ol start="3">
<li><code>GCD</code>更接近底层，<code>GCD</code>在追求性能的底层操作来说，是速度最快的。</li>
</ol>
</li>
<li>
<ol start="4">
<li>从异步操作之间的事务性，顺序行，依赖关系。<code>GCD</code>需要自己写更多的代码来实现，而<code>NSOperation</code>已经内建了这些支持。</li>
</ol>
</li>
<li>
<ol start="5">
<li>如果异步操作的过程需要更多的被交互和UI呈现出来，<code>NSOperation</code>更好。底层代码中，任务之间不太互相依赖，而需要更高的并发能力，<code>GCD</code>则更有优势。</li>
</ol>
</li>
</ul>
<p><strong>线程池原理</strong></p>
<ul>
<li>
<p>使用线程执行任务的时候，需要到线程池中去取线程进行任务分配。</p>
</li>
<li>
<p>首先判断线程池大小是否小于核心线程池大小，如果小于的话，创建新的线程执行任务；</p>
</li>
<li>
<p>如果当前小城池大小<strong>大于</strong>了核心线程池大小，然后开始判断工作队列是否已满，如果没满，将任务提交到工作队列。</p>
</li>
<li>
<p>如果工作队列已满，判断线程池的线程是否都在工作，如果有空闲线程没有在工作，就交给它去执行任务。</p>
</li>
<li>
<p>如果线程池中的线程都在工作，那么就交给饱和策略去执行。</p>
</li>
</ul>
<p><strong>饱和策略分为下面四种：</strong></p>
<ul>
<li>
<p><code>AbortPolicy</code> 直接抛出<code>RejectedExecutionExeception</code> 异常来阻止系统正常运行；</p>
</li>
<li>
<p><code>CallerRunsPolicy</code> 将任务回退到调用者；</p>
</li>
<li>
<p><code>DisOldestPolicy</code> 丢掉等待最久的任务‘；</p>
</li>
<li>
<p><code>DisCardPolicy</code> 直接丢弃任务。</p>
</li>
</ul>
<p><strong>线程间通讯</strong></p>
<p>直接同步或者异步向任务队列添加任务。</p>
<p>通过NSPort端口的形式进行发送消息，实现不同的线程间的通信。使用的时候注意需要将NSPort加入的线程的RunLoop中去。</p>
<ul>
<li>
<p>**直接消息传递：**通过<code>performSelector</code>的一系列方法，可以实现由某一线程指定在另外的线程上执行任务。因为任务的执行上下文是目标线程，这种方式发送的消息将会自动的被序列化。</p>
</li>
<li>
<p>**全局变量、共享内存块和对象：**在两个线程之间传递信息的另一种简单方法是使用全局变量，共享对象或共享内存块。尽管共享变量既快速又简单，但是它们比直接消息传递更脆弱。必须使用锁或其他同步机制仔细保护共享变量，以确保代码的正确性。 否则可能会导致竞争状况，数据损坏或崩溃。</p>
</li>
<li>
<p>**条件执行：**条件是一种同步工具，可用于控制线程何时执行代码的特定部分。您可以将条件视为关守，让线程仅在满足指定条件时运行。</p>
</li>
<li>
<p><strong>Runloop sources：<strong>一个自定义的<code>Runloop source配置</code>可以让一个线程上收到特定的应用程序消息。由于<code>Runloop source</code>是</strong>事件驱动</strong>的，因此在无事可做时，线程会自动进入睡眠状态，从而提高了线程的效率。</p>
</li>
<li>
<p>**Ports and sockets：**基于端口的通信是在两个线程之间进行通信的一种更为复杂的方法，但它也是一种非常可靠的技术。更重要的是，端口和套接字可用于与外部实体（例如其他进程和服务）进行通信。为了提高效率，使用<code>Runloop source</code>来实现端口，因此当端口上没有数据等待时，线程将进入睡眠状态。</p>
</li>
<li>
<p>**消息队列：**传统的多处理服务定义了<code>先进先出（FIFO）队列</code>抽象，用于管理传入和传出数据。尽管消息队列既简单又方便，但是它们不如其他一些通信技术高效。</p>
</li>
<li>
<p>**Cocoa 分布式对象：**分布式对象是一种 Cocoa 技术，可提供基于端口的通信的高级实现。尽管可以将这种技术用于线程间通信，但是强烈建议不要这样做，因为它会产生大量开销。分布式对象更适合与其他进程进行通信，尽管在这些进程之间进行事务的开销也很高。</p>
</li>
</ul>
<p><strong>线程安全</strong>就是在同一时刻，对同一个数据操作的线程只有一个。这时就用到了锁。</p>
<ul>
<li>
<p>**锁：**是保证线程安全的同步工具。每一个线程在访问数据资源之前，要先获取(acquire)锁，然后在访问结束之后释放(release)锁。如果锁已经被占用，其它要获取锁的线程会等待，直到锁重新可用。</p>
</li>
<li>
<p>iOS中的锁分为<strong>互斥锁</strong>、<strong>自旋锁</strong>、<strong>信号量</strong>这三种。<br />
**互斥锁：**就是在多线程编程中，防止两条线程同时对同一公共资源(比如全局变量)进行读写。</p>
</li>
</ul>
<p><code>@synchronized</code>：是递归锁</p>
<ul>
<li>
<p>调用<code>synchronzied</code>的每个对象，<code>runtime</code>都会为其分配一个递归锁并存储在哈希表中。</p>
</li>
<li>
<p>如果在<code>synchronzied</code>内部对象被释放或为nil，会执行类似<code>objc_sync_nil</code>的空方法。</p>
</li>
<li>
<p>注意不要像<code>synchronzied</code>传入<code>nil</code> , 这将会从代码中移走线程安全。</p>
</li>
</ul>
<p><code>NSLock：</code>遵循 NSLocking 协议，<code>lock</code>方法是加锁，<code>unlock</code>是解锁，<code>tryLock</code>是尝试加锁，如果失败的话返回 NO，<code>lockBeforeDate</code>: 是在指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。注意不能多次调用lock方法，会造成死锁。</p>
<p>**自旋锁：**线程会反复检查锁变量是否可用，线程在这一过程中保持执行，是一种忙等待，一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁，自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。<code>atomic</code>就是通过个set和get方法添加一个自旋锁。</p>
<p><strong>信号量：</strong> <code>dispatch_semaphore</code></p>
<p><strong>使用：</strong></p>
<ul>
<li>
<p>1). 通过<code>dispatch_semaphore_create(value)</code>创建一个信号量，初始为1。</p>
</li>
<li>
<p>2). 等待信号量<code>dispatch_semaphore_wait</code>，可以理解为lock加锁，会使信号量-1。</p>
</li>
<li>
<p>3). 发送信号量<code>dispatch_semaphore_signal</code>，可以理解为 unlock解锁，会使 <code>signal</code> 信号量+1。</p>
</li>
</ul>
<p>互斥锁是 <code>dispatch_semaphore</code>在取值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不仅仅是线程间互斥。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字典注意事项：setvalue和setobject的区别]]></title>
    <link href="platojobs.cn/17218114654568.html"/>
    <updated>2024-07-24T16:57:45+08:00</updated>
    <id>platojobs.cn/17218114654568.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<p><code>setObject:ForKey</code>：是<code>NSMutableDictionary</code>特有的。</p>
</li>
<li>
<p><code>setValue:ForKey</code>：是<code>KVC</code>的主要方法。</p>
</li>
<li>
<p><code>setobject</code>中的<code>key</code>和<code>value</code>可以为nil以外的任何对象。</p>
</li>
<li>
<p><code>setValue</code>中的key只能为字符串，value可以为<code>nil</code>也可以为空对象<code>[NSNull null]</code>以及全部对象</p>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何实现week]]></title>
    <link href="platojobs.cn/17218114532911.html"/>
    <updated>2024-07-24T16:57:33+08:00</updated>
    <id>platojobs.cn/17218114532911.html</id>
    <content type="html"><![CDATA[
<p>**weak：**该属性定义了一种非拥有关系。为属性设置新值时，设置方法既不持有新值，也不释放旧值。</p>
<p><strong>weak实现原理：</strong></p>
<ul>
<li>
<ol>
<li>当一个对象被weak指针指向时，这个weak指针会以对象为key，存储到<code>sideTable类</code>的<code>weak_table</code>散列表上对应的一个weak指针数组里面。</li>
</ol>
</li>
<li>
<ol start="2">
<li>当一个对象的<code>dealloc</code>方法被调用时，<code>Runtime</code>会以<code>obj</code>为<code>key</code>，从<code>sideTable</code>的<code>weak_table</code>散列表中，找出对应的weak指针列表，然后将里面的weak指针逐个置为<code>nil</code>。</li>
</ol>
</li>
</ul>
<p><code>key</code>是<strong>weak指向的对象内存地址</strong>，<code>value</code>是<strong>所有指向该对象的weak指针表</strong>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分类(category)和类扩展(extension)的区别]]></title>
    <link href="platojobs.cn/17218114350868.html"/>
    <updated>2024-07-24T16:57:15+08:00</updated>
    <id>platojobs.cn/17218114350868.html</id>
    <content type="html"><![CDATA[
<ul>
<li>1). 分类实现原理</li>
</ul>
<p><code>Category</code>编译之后的底层结构是<code>struct category_t</code>，里面存储着分类的对象方法、类方法、属性、协议信息。在程序运行的时候，<code>runtime</code>会将<code>Category</code>的数据，合并到类信息中（类对象、元类对象中）。</p>
<ul>
<li>
<p>2). Category和Extension的区别是什么？</p>
<ul>
<li>
<p>类扩展可以为类添加私有变量和私有方法，在类的源文件中书写，不能被子类继承，类扩展在编译的时候，它的数据就已经包含在类信息中。</p>
</li>
<li>
<p>分类可以为类添加方法并且可以被子类继承，因为分类是运行时才会将数据合并到类信息中。但是分类不能直接添加属性，需要借助运行时关联对象。</p>
</li>
</ul>
</li>
<li>
<p>3). 分类为啥不能添加成员变量?</p>
</li>
</ul>
<pre><code class="language-plain_text">struct _category_t {
	const char *name;
	struct _class_t *cls;
	const struct _method_list_t *instance_methods;
	const struct _method_list_t *class_methods;
	const struct _protocol_list_t *protocols;
	const struct _prop_list_t *properties;
};
</code></pre>
<ul>
<li>
<p>从结构体可以知道，有<code>属性列表</code>，所以分类可以声明属性，但是分类只会生成该属性对应的<code>get和set的声明</code>，没有去实现该方法。</p>
</li>
<li>
<p>结构体没有成员变量列表，所以不能声明成员变量。</p>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类的继承，类能否多继承，协议能不能做继承]]></title>
    <link href="platojobs.cn/17218114171616.html"/>
    <updated>2024-07-24T16:56:57+08:00</updated>
    <id>platojobs.cn/17218114171616.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<p>OC的类不支持多继承只支持单继承。</p>
</li>
<li>
<p>协议可以实现多继承，遵循多个协议即可。</p>
</li>
<li>
<p>消息的转发也可以实现多继承，但并不建议，维护成本高。</p>
</li>
</ul>
<p><strong>继承和类别在实现中有何区别？</strong></p>
<ul>
<li>
<p><code>category</code> 可以在不获悉、不改变原来代码的情况下往里面添加并且只能添加方法不能删除修改。 如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。类别不会影响到其他类与原有类的关系。</p>
</li>
<li>
<p>类别主要有3个作用：</p>
<ul>
<li>
<p>(1)将类的实现分散到多个不同文件或多个不同框架中。</p>
</li>
<li>
<p>(2)创建对私有方法的前向引用。</p>
</li>
<li>
<p>(3)向对象添加非正式协议。</p>
</li>
</ul>
</li>
<li>
<p>继承可以增加，修改或者删除方法，并且可以增加属性。</p>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa的使用及优缺点]]></title>
    <link href="platojobs.cn/17218114016336.html"/>
    <updated>2024-07-24T16:56:41+08:00</updated>
    <id>platojobs.cn/17218114016336.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><strong>ReactiveCocoa</strong>简称RAC，是函数响应式编程框架，因为它具有函数式编程和响应式编程的特性。</p>
</blockquote>
<ul>
<li>
<p>由于该框架的编程思想，使得它具有相当魅惑人心的功能，它能实现传统设计模式和事件监听所能实现的功能，比如<strong>KVO、通知、block回调、action、协议</strong>等等，它的全面性并不是它最为优越的特色，RAC最值得炫耀的是它提供了统一的消息传递机制，这种机制使得它的代码更加的简洁，同一功能代码块更少，这正是符合了我们编程的思想：高聚合、低耦合，它非常适合MVVM设计模式的开发。</p>
</li>
<li>
<p>不过它也并不能完全取代传统的编码方式，在多人开发和代码维护方面，RAC还是有着一些让人头痛的问题。</p>
</li>
</ul>
<p>**优点：**使用灵活方便、代码简洁、逻辑清晰</p>
<p>**缺点：**维护成本较高、问题溯源困难</p>
<p><strong>使用：</strong></p>
<p>RAC的统一消息传递机制，其所以动作都离不开<code>信号(sigal)</code>。</p>
<ul>
<li>1). <strong>信号的创建、发送、接收</strong></li>
</ul>
<pre><code class="language-plain_text">// 创建  此时为冷信号，并不会被触发
RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscribersubscriber) {  
    // 发送信号  
    [subscriber sendNext:@&quot;oh my god&quot;];  
    // 回收资源。注意：手动创建一个signal一定要记得回收资源，不然程序会崩溃
    return [RACDisposable disposableWithBlock:^{  
        NSLog(@&quot;信号发送完成&quot;);  
    }];  
}];  
// 订阅信号后才会变为热信号，可以被触发
[signal subscribeNext:^(id x) {  
    NSLog(@&quot;singalContent:%@&quot;, x);  
}];  
</code></pre>
<ul>
<li>2). <strong>RAC的ControlEvents</strong><br />
这个方法可以简单的实现监听操作，并且逻辑在其后的<code>block</code>中处理，而且也能添加手势并进行监听。</li>
</ul>
<pre><code class="language-plain_text">[[self.textField rac_signalForControlEvents:UIControlEventEditingDidBegin] subscribeNext:^(id x) {  
    NSLog(@&quot;%@&quot;, x);  
}];  

UITapGestureRecognizer *tap = [UITapGestureRecognizer new];  
[[tap rac_gestureSignal] subscribeNext:^(id x) {  
    NSLog(@&quot;three:%@&quot;, x);  
}];  
[self.view addGestureRecognizer:tap];  
</code></pre>
<ul>
<li>3). <strong>RAC的KVO</strong></li>
</ul>
<pre><code class="language-plain_text">[[self.textField rac_valuesAndChangesForKeyPath:@&quot;text&quot; options:NSKeyValueObservingOptionNew observer:self] subscribeNext:^(id x) {  
    NSLog(@&quot;%@&quot;, x);  
}];  
</code></pre>
<ul>
<li>4). <strong>RAC的通知</strong></li>
</ul>
<pre><code class="language-plain_text">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardDidShowNotification object:nil] subscribeNext:^(id x) {  
    NSLog(@&quot;键盘弹起&quot;);  
}];  
</code></pre>
<ul>
<li>5). <strong>RAC的协议</strong></li>
</ul>
<pre><code class="language-plain_text">- (void)viewDidLoad {  
    [super viewDidLoad];  
    // 代理  
    self.textField.delegate = self;  
    [[self rac_signalForSelector:@selector(textFieldDidBeginEditing:) fromProtocol:@protocol(UITextFieldDelegate)] subscribeNext:^(id x) {  
        NSLog(@&quot;打印点击信息:%@&quot;, x);  
    }];  
}  
- (void)textFieldDidBeginEditing:(UITextField *)textField {  
    NSLog(@&quot;开始编辑了&quot;);  
}  
</code></pre>
<ul>
<li>6). <strong>RAC遍历数组和字典</strong></li>
</ul>
<p>相当于枚举遍历，但是效率相比更高</p>
<pre><code class="language-plain_text">NSArray *arr = @[@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;, @&quot;4&quot;, @&quot;5&quot;];  
[arr.rac_sequence.signal subscribeNext:^(id x) {  
    NSLog(@&quot;arr : %@&quot;, x);  
}];  
NSDictionary *dic = @{@&quot;name&quot;:@&quot;yangBo&quot;, @&quot;age&quot;:@&quot;19&quot;};  
[dic.rac_sequence.signal subscribeNext:^(id x) {  
    NSLog(@&quot;dic : %@&quot;, x);  
}];  
</code></pre>
<ul>
<li>7). <strong>RAC信号处理（map、filter、combine）</strong></li>
</ul>
<p>① 对信号不做处理</p>
<pre><code class="language-plain_text">[[self.textField rac_textSignal] subscribeNext:^(id x) {  
    NSLog(@&quot;doNothing:%@&quot;, x);  
}];  
</code></pre>
<p>② 对信号进行过滤（filter）<br />
可以对信号进行条件判断是否处理。</p>
<pre><code class="language-plain_text">[[[self.textField rac_textSignal] filter:^BOOL(NSString* value) {
    if (value.length 3) {
        return YES;
    }
    return NO;
}] subscribeNext:^(id x) {
    NSLog(@&quot;filter:%@&quot;, x);
}];
</code></pre>
<p>③ 对信号进行映射（map）<br />
映射也可以理解为<strong>转换</strong>，第一个block返回的是id类型，如果返回<code>&quot;map now&quot;</code>，就相当于信号转换，第二个block打印的值就是你return的值<code>&quot;map now&quot;</code>。</p>
<pre><code class="language-plain_text">[[[self.textField rac_textSignal] map:^id(NSString* value) {
    if (value.length 3) {
        return @&quot;map now&quot;;
    }
    return value;
}] subscribeNext:^(id x) {
    NSLog(@&quot;map:%@&quot;, x);
}];
</code></pre>
<p>④ <strong>信号的联合（combine）</strong></p>
<pre><code class="language-plain_text">// 创建需要联合的信号
RACSignal *firstCombineSignal = [self.textField rac_textSignal];
RACSignal *secondeCombineSignal = [tap rac_gestureSignal];
// 信号联合处理返回self.label的背景色
RAC(self.label, backgroundColor) = [RACSignal combineLatest:@[firstCombineSignal, secondeCombineSignal] reduce:^id(NSString *text, UITapGestureRecognizer * tap){
    // 这里进行信号逻辑判断和处理
    if (text.length == 3 &amp;&amp; tap.state == UIGestureRecognizerStateEnded) {
        return [UIColor redColor];
    }
    return [UIColor cyanColor];
}];
</code></pre>
<p>⑤ <strong>信号关联</strong></p>
<pre><code class="language-plain_text">RAC(self.label, text) = [self.textField rac_textSignal];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[架构设计]]></title>
    <link href="platojobs.cn/17218113793678.html"/>
    <updated>2024-07-24T16:56:19+08:00</updated>
    <id>platojobs.cn/17218113793678.html</id>
    <content type="html"><![CDATA[
<p>**MVC：</p>
<ul>
<li>
<p><strong>M</strong> 是数据模型<code>Model</code>，负责处理数据，以及数据改变时发出通知(<code>Notification、KVO</code>)，<code>Model</code>和<code>View</code>不能直接进行通信，这样会违背MVC设计模式；</p>
</li>
<li>
<p><strong>V</strong> 是视图<code>View</code>，用来展示界面，和用户进行交互，为了解耦合一般不会直接持有 或者 操作数据层中的数据模型(可以通过<code>action-target</code>、<code>delegate</code>、<code>block</code>等方式解耦)；</p>
</li>
<li>
<p><strong>C</strong> 是控制器<code>Controller</code>用来调节<code>Model</code>和<code>View</code>之间的交互，可以直接与Model还有View进行通信，操作Model进行数据更新，刷新View。</p>
<p><strong>优点：</strong><code>View</code>、<code>Model</code>低耦合、高复用、容易维护。</p>
<p><strong>缺点：</strong><code>Controller</code>的代码过于臃肿，如果<code>View</code>与<code>Model</code>直接交互会导致<code>View</code>和<code>Model</code>之间的耦合性比较大、网络逻辑会加重<code>Controller</code>的臃肿。</p>
</li>
</ul>
<p><strong>MVVM：</strong><code>Model - View - ViewModel</code></p>
<ul>
<li>
<p><strong>MVVM</strong>衍生于<strong>MVC</strong>，是MVC的一种演进，促进了UI代码和业务逻辑的分离，抽取<code>Controller</code>中的展示逻辑放到<code>ViewModel</code>里边。</p>
</li>
<li>
<p><strong>M：</strong> 数据模型<code>Model</code>。</p>
</li>
<li>
<p><strong>V：</strong> 就是<code>View</code>和<code>Controller</code>联系到一起，视为是一个组件<code>View</code>。View和Controller都不能直接引用模型Model，可以引用视图模型ViewModel。ViewController 尽量不涉及业务逻辑，让 ViewModel 去做这些事情。ViewController 只是一个中间人，负责接收 View 的事件、调用 ViewModel 的方法、响应 ViewModel 的变化。</p>
</li>
<li>
<p><strong>VM：</strong><code>ViewModel</code>负责封装业务逻辑、网络处理和数据缓存。使用ViewModel会轻微的增加代码量，但是总体上减少了代码的复杂性。<code>ViewModel</code>之间可以有依赖。</p>
</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>
<p><code>View</code>引用<code>ViewModel</code>，但反过来不行，因为如果VM跟V产生了耦合，不方便复用。即不要在<code>viewModel</code>中引入<code>#import UIKit.h</code>，任何视图本身的引用都不应该放在<code>viewModel</code>中 (<strong>注意：基本要求，必须满足</strong>)。</p>
</li>
<li>
<p><code>ViewModel</code>可以引用<code>Model</code>，但反过来不行。</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<p>低耦合、可复用、数据流向清晰、而且兼容MVC，便于代码的移植、并且ViewModel可以拆出来独立开发、方便测试。</p>
<p><strong>缺点：</strong><br />
类会增多、<code>ViewModel</code>会越来越庞大、调用复杂度增加、双向绑定数据会导致问题调试变得困难。</p>
<p><strong>总结：</strong></p>
<ul>
<li>
<p><strong>MVVM</strong>其实是MVC的变种。<code>MVVM</code>只是帮<code>MVC</code>中的<code>Controller</code>瘦身，把一些逻辑代码和网络请求分离出去。不让Controller处理更多的东西，不会变得臃肿，<code>MVVM</code>和<code>MVC</code>可以根据实际需求进行灵活选择。</p>
</li>
<li>
<p><strong>MVVM</strong> 在使用当中，通常还会利用双向绑定技术，使得<code>Model</code> 变化时，<code>ViewModel</code>会自动更新，而<code>ViewModel</code>变化时，<code>View</code> 也会自动变化。OC中可以用**RAC(ReactiveCocoa)**函数响应式框架来实现响应式编程。</p>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式]]></title>
    <link href="platojobs.cn/17218113620111.html"/>
    <updated>2024-07-24T16:56:02+08:00</updated>
    <id>platojobs.cn/17218113620111.html</id>
    <content type="html"><![CDATA[
<p><strong>创建型模式：</strong></p>
<ul>
<li>
<p>**单例模式：**在整个应用程序中，共享一份资源。保证在程序运行过程中，一个类只有一个实例，而且该实例只提供一个全局访问点供外界访问，从而方便控制实例个数，节约系统资源。</p>
<p>**优点是：**提供了对唯一实例的受控访问、可扩展、避免频繁创建销毁对象影响性能。</p>
<p>**缺点是：**延长了声明周期，一直存在占用内存。如果两个单例循环依赖会造成死锁，所以尽量不去产生单例间的依赖关系。</p>
</li>
<li>
<p>**工厂方法模式：**通过类继承创建抽象产品，创建一种产品，子类化创建者并重载工厂方法以创建新产品。</p>
</li>
<li>
<p>**抽象工厂模式：**通过对象组合创建抽象产品，可以创建多系列产品，必须修改父类的接口才能支持新的产品。</p>
</li>
</ul>
<p><strong>结构型模式：</strong></p>
<ul>
<li>**代理模式：**代理用来处理事件的监听和参数传递。<code>@required</code>修饰必须实现这个协议方法方法，<code>@optional</code>修饰是可选实现。使用方法时最好先判断方法是否实现<code>respondsToSelector: </code>，避免找不到方法而崩溃。</li>
</ul>
<blockquote>
<p>**delegate和block、Notification对比优缺点：**delegate和block是一对一通信、block比delegate更加简洁清晰，但是如果通信事件较多时delegate运行成本较低且不易造成循环引用；通知适合一对多通信，代码清晰简单，但问题查找溯源会比较困难，并且注册通知要注意在合适的时间移除，避免对野指针发送消息引起崩溃（**注意：**iOS9之后已经做了弱引用处理不需要移除了，之前版本使用不安全引用__unsafe_unretained是为了兼容旧版本）。</p>
</blockquote>
<ul>
<li>
<p>**类簇：**见上边 5. 类簇</p>
</li>
<li>
<p>**装饰模式：**在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。如：<strong>分类</strong>。</p>
</li>
<li>
<p>**享元模式：使用共享物件，减少同一类对象的大量创建。如：**UITableviewCell复用。</p>
</li>
</ul>
<p><strong>行为型模式：</strong></p>
<ul>
<li>
<p>**观察者模式：**其本质上是一种<code>发布-订阅</code>模型，用来消除具有不同行为的对象之间的耦合，通过这一模式，不同对象可以协同工作。如：<strong>KVO</strong>。</p>
</li>
<li>
<p><strong>命令模式：<strong>是一种将方法调用封装为对象的设计模式，在iOS中具体实现为</strong>NSInvocation</strong>。下边为<code>NSInvocation</code>的实现代码。</p>
</li>
</ul>
<pre><code class="language-plain_text">- (void)viewDidLoad {
    NSMethodSignature *signature = [ViewController instanceMethodSignatureForSelector:@selector(sendMessageWithPhone:WithName:)]; // 方法签名：用来获得方法的返回类型和参数类型
    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
    invocation.target = self; // 目标：接收消息的对象
    invocation.selector = @selector(sendMessageWithPhone:WithName:); // 选择器：被发送的消息, 方法必须和签名中的方法一致。
    
    NSString *phone = @&quot;13512345678&quot;;
    // 注意：设置参数的索引时不能从0开始，因为0已经被self占用，1已经被_cmd占用
    [invocation setArgument:&amp;phone atIndex:2]; // 参数：可以添加任意数量的参数。
    NSString *name = @&quot;Dezi&quot;;
    [invocation setArgument:&amp;name atIndex:3];
    /*
     注：调用invocation的invoke方法，就代表需要执行NSInvocation对象中指定对象的指定方法，并且传递指定的参数
     */
    [invocation invoke];
}
- (void)sendMessageWithPhone:(NSString*)phone WithName:(NSString*)name {
    NSLog(@&quot;电话号=%@, 姓名=%@&quot;,phone, name);
}
// 电话号=13512345678, 姓名Dezi
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类簇]]></title>
    <link href="platojobs.cn/17218113284689.html"/>
    <updated>2024-07-24T16:55:28+08:00</updated>
    <id>platojobs.cn/17218113284689.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><strong>类簇</strong>是Foundation框架中广泛使用的设计模式。<strong>类簇在公共抽象超类下对多个私有的具体子类进行分组</strong>。以这种方式对类进行分组简化了面向对象框架的公共可见体系结构，而不会降低其功能丰富度。<strong>类簇是基于抽象工厂设计模式的</strong>。</p>
</blockquote>
<p>常见的类簇有 <code>NSString</code>、<code>NSArray</code>、<code>NSDictionary</code>等。<br />
**以数组为例：**不管创建的是可变还是不可变的数组，在<code>alloc</code>之后得到的类都是 <code>__NSPlaceholderArray</code>。而当我们 <code>init</code> 一个不可变的空数组之后，得到的是<code> __NSArray0</code>；如果有且只有一个元素，那就是 <code>__NSSingleObjectArrayI</code>；有多个元素的，叫做 <code>__NSArrayI</code>；<code>init</code> 出来一个可变数组的话，都是 <code>__NSArrayM</code>。</p>
<p><strong>优点：</strong></p>
<ul>
<li>
<p>可以将抽象基类背后的复杂细节隐藏起来。</p>
</li>
<li>
<p>程序员不会需要记住各种创建对象的具体类实现，简化了开发成本，提高了开发效率。</p>
</li>
<li>
<p>便于进行封装和组件化。</p>
</li>
<li>
<p>减少了 if-else 这样缺乏扩展性的代码。</p>
</li>
<li>
<p>增加新功能支持不影响其他代码。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>已有的类簇非常不好扩展。</li>
</ul>
<p><strong>我们运用类簇的场景：</strong></p>
<ul>
<li>
<ol>
<li>出现 bug 时，可以通过崩溃报告中的类簇关键字，快速定位 bug 位置。</li>
</ol>
</li>
<li>
<ol start="2">
<li>在实现一些固定且并不需要经常修改的事物时，可以高效的选择类簇去实现。例：</li>
</ol>
<ul>
<li>
<ul>
<li>针对不同版本，不同机型往往需要不同的设置，这时可以选择使用类簇。</li>
</ul>
</li>
<li>
<ul>
<li>app 的设置页面这种并不需要经常修改的页面，可以使用类簇去创建大量重复的布局代码。</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[成员变量`ivar`和属性`property`的区别，以及不同关键字的作用]]></title>
    <link href="platojobs.cn/17218113068592.html"/>
    <updated>2024-07-24T16:55:06+08:00</updated>
    <id>platojobs.cn/17218113068592.html</id>
    <content type="html"><![CDATA[
<p>**成员变量：**成员变量的默认修饰符是<code>@protected</code>、不会自动生成set和get方法，需要手动实现、不能使用点语法调用，因为没有set和get方法，只能使用<code>-&gt;</code>。</p>
<p>**属性：**属性会默认生成带下划线的成员变量和<code>setter/getter</code>方法、可以用点语法调用，实际调用的是set和get方法。</p>
<p><strong>注意：分类中添加的属性是不会自动生成  <code>setter/getter</code>方法的，必须要手动添加。</strong></p>
<p>**实例变量：**class类进行实例化出来的对象为实例对象</p>
<p><strong>关键字作用：</strong></p>
<ul>
<li><strong>访问范围关键字</strong></li>
</ul>
<ul>
<li>
<p><code>@public</code>：声明公共实例变量，在任何地方都能直接访问对象的成员变量。</p>
</li>
<li>
<p><code>@private</code>：声明私有实例变量，只能在当前类的对象方法中直接访问，子类要访问需要调用父类的get/set方法。</p>
</li>
<li>
<p><code>@protected</code>：可以在当前类及其子类对象方法中直接访问(系统默认)。</p>
</li>
<li>
<p><code>@package</code>：在同一个包下就可以直接访问，比如说在同一个框架。</p>
</li>
</ul>
<ul>
<li><strong>关键字</strong></li>
</ul>
<ul>
<li>
<p><code>@property</code>：声明属性，自动生成一个以下划线开头的成员变量_propertyName(默认用@private修饰)、属性setter、getter方法的声明、属性setter、getter方法的实现。**注意：**在<code>协议@protocol</code>中只会生成getter和setter方法的声明，所以不仅需要手动实现getter和setter方法还需要手动定义变量。</p>
</li>
<li>
<p><code>@sythesize</code>：修改@property自动生成的_propertyName成员变量名，<code>@synthesize propertyName = newName；</code>。</p>
</li>
<li>
<p><code>@dynamic</code>：告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。**谨慎使用：**如果对属性赋值取值可以编译成功，但运行会造成程序崩溃，这就是常说的动态绑定。</p>
</li>
<li>
<p><code>@interface</code>：声明类</p>
</li>
<li>
<p><code>@implementation</code>：类的实现</p>
</li>
<li>
<p><code>@selecter</code>：创建一个SEL，类成员指针</p>
</li>
<li>
<p><code>@protocol</code>：声明协议</p>
</li>
<li>
<p><code>@autoreleasepool</code>：ARC中的自动释放池</p>
</li>
<li>
<p><code>@end</code>：类结束</p>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[property和属性修饰符]]></title>
    <link href="platojobs.cn/17218112789594.html"/>
    <updated>2024-07-24T16:54:38+08:00</updated>
    <id>platojobs.cn/17218112789594.html</id>
    <content type="html"><![CDATA[
<p><strong>@property的本质</strong>是 <code>ivar(实例变量)</code> + <code>setter</code> + <code>getter</code>.</p>
<p><strong>我们每次增加一个属性时内部都做了什么：</strong></p>
<ul>
<li>
<p>1.系统都会在 <code>ivar_list</code> 中添加一个成员变量的描述；</p>
</li>
<li>
<p>2.在 <code>method_list</code> 中增加 <code>setter</code> 与 <code>getter</code> 方法的描述；</p>
</li>
<li>
<p>3.在属性列表中增加一个属性的描述；</p>
</li>
<li>
<p>4.然后计算该属性在对象中的偏移量；</p>
</li>
<li>
<p>5.给出 <code>setter</code> 与 <code>getter</code> 方法对应的实现，在 <code>setter</code> 方法中从偏移量的位置开始赋值，在 <code>getter</code> 方法中从偏移量开始取值，为了能够读取正确字节数，系统对象偏移量的指针类型进行了类型强转。</p>
</li>
</ul>
<p><strong>修饰符：</strong></p>
<ul>
<li>
<p><strong>MRC下：</strong> <code>assign、retain、copy、readwrite、readonly、nonatomic、atomic</code>等。</p>
</li>
<li>
<p><strong>ARC下：</strong><code>assign、strong、weak、copy、readwrite、readonly、nonatomic、atomic、nonnull、nullable、null_resettable、_Null_unspecified</code>等。</p>
</li>
</ul>
<p>下面分别解释</p>
<ul>
<li>
<p><code>assign</code>：用于基本数据类型，不更改引用计数。如果修饰对象(对象在堆需手动释放内存，基本数据类型在栈系统自动释放内存)，会导致对象释放后指针不置为nil 出现野指针。</p>
</li>
<li>
<p><code>retain</code>：和strong一样，释放旧对象，传入的新对象引用计数+1；在MRC中和release成对出现。</p>
</li>
<li>
<p><code>strong</code>：在ARC中使用，告诉系统把这个对象保留在堆上，直到没有指针指向，并且ARC下不需要担心引用计数问题，系统会自动释放。</p>
</li>
<li>
<p><code>weak</code>：在被强引用之前，尽可能的保留，不改变引用计数；weak引用是弱引用，你并没有持有它；它本质上是分配一个不被持有的属性，当引用者被销毁(dealloc)时，weak引用的指针会自动被置为nil。<strong>可以避免循环引用。</strong></p>
</li>
<li>
<p><code>copy</code>：一般用来修饰不可变类型属性字段，如：<code>NSString</code>、<code>NSArray</code>、<code>NSDictionary</code>等。用copy修饰可以防止本对象属性受外界影响，在<code>NSMutableString</code>赋值给<code>NSString</code>时，修改前者 会导致 后者的值跟着变化。还有<code>block</code>也经常使用 copy 修饰符，但是其实在ARC中编译器会自动对block进行copy操作，和strong的效果是一样的。但是在MRC中方法内部的block是在栈区，使用copy可以把它放到堆区。</p>
</li>
<li>
<p><code>readwrite</code>：可以读、写；编译器会自动生成setter/getter方法。</p>
</li>
<li>
<p><code>readonly</code>：只读；会告诉编译器不用自动生成setter方法。属性不能被赋值。</p>
</li>
<li>
<p><code>nonatomic</code>：非原子性访问。用nonatomic意味着可以多线程访问变量，会导致读写线程不安全。但是会提高执行性能。</p>
</li>
<li>
<p><code>atomic</code>：原子性访问。编译器会自动生成互斥锁，对 setter 和 getter 方法进行加锁来保证属性的 赋值和取值 原子性操作是线程安全的，但不包括可变属性的操作和访问。比如我们对数组进行操作，给数组添加对象或者移除对象，是不在atomic的负责范围之内的，所以给被atomic修饰的数组添加对象或者移除对象是没办法保证线程安全的。<strong>原子性访问的缺点是会消耗性能导致执行效率慢。</strong></p>
</li>
<li>
<p><code>nonnull</code>：设置属性或方法参数不能为空，专门用来修饰指针的，不能用于基本数据类型。</p>
</li>
<li>
<p><code>nullable</code>：设置属性或方法参数可以为空。</p>
</li>
<li>
<p><code>null_resettable</code>：设置属性，get方法不能返回为空，set方法可以赋值为空。</p>
</li>
<li>
<p><code>_Null_unspecified</code>：设置属性或方法参数不确定是否为空。</p>
</li>
</ul>
<blockquote>
<p>后四个属性应该主要就是为了提高开发规范，提示使用的人应该传什么样的值，如果违反了对规范值的要求，就会有警告。</p>
</blockquote>
<p><strong>weak修饰的对象释放则自动被置为nil的实现原理：</strong></p>
<p><code>Runtime</code>维护了一个<code>weak表</code>，存储指向某个对象的所有<code>weak指针</code>。<code>weak表</code>其实是一个<code>hash（哈希）表</code>，<code>Key</code>是所指对象的地址，<code>Value</code>是<code>weak</code>指针的地址数组（这个地址的值是所指对象的地址）。</p>
<p><strong>weak 的实现原理可以概括一下三步：</strong></p>
<ul>
<li>
<p>1、初始化时：<code>runtime</code>会调用<code>objc_initWeak</code>函数，初始化一个新的weak指针指向对象的地址。</p>
</li>
<li>
<p>2、添加引用时：<code>objc_initWeak</code>函数会调用 <code>objc_storeWeak()</code>函数， <code>objc_storeWeak()</code> 的作用是更新指针指向，创建对应的弱引用表。</p>
</li>
<li>
<p>3、释放时，调用<code>clearDeallocating</code>函数。<code>clearDeallocating</code>函数首先根据对象地址获取所有<code>weak</code>指针地址的数组，然后遍历这个数组把其中的数据设为<code>nil</code>，最后把这个entry从weak表中删除，最后清理对象的记录。</p>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC数据类型]]></title>
    <link href="platojobs.cn/17218112314212.html"/>
    <updated>2024-07-24T16:53:51+08:00</updated>
    <id>platojobs.cn/17218112314212.html</id>
    <content type="html"><![CDATA[
<p><img src="media/17218112314212/17218112522645.png" alt="" /></p>
<p><strong>① 基本数据类型</strong></p>
<ul>
<li>
<p>C语言基本数据类型（如<code>short、int、float</code>等）在OC中都不是对象，只是一定字节的内存空间用于存储数值，他们都不具备对象的特性，没有属性方法可以被调用。</p>
</li>
<li>
<p><strong>OC中的基本数据类型：</strong></p>
<ul>
<li><code>NSInteger</code>(相当于long型整数)、</li>
<li><code>NSUInteger</code>(相当于unsigned long型整数)、</li>
<li><code>CGFloat</code>(在64位系统相当于double，32位系统相当于float)等。</li>
<li>他们并不是类，只是用<code>typedef</code>对基本数据类型进行了重定义，<strong><code>他们依然只是基本数据类型</code></strong>。</li>
<li>**枚举类型：**其本质是无符号整数。</li>
<li>**BOOL类型：**是宏定义，OC底层是使用signed char来代表BOOL。</li>
</ul>
</li>
</ul>
<p><strong>② 指针数据类型</strong></p>
<p><strong>指针数据类型包括：</strong> <code>类class</code>、<code>id</code>。</p>
<ul>
<li><strong>类class：</strong><code>NSString</code>、<code>NSSet</code>、<code>NSArray</code>、<code>NSMutableArray</code>、<code>NSDictionary</code>、<code>NSMutableDictionary</code>、<code>NSValue</code>、<code>NSNumber(继承NSValue)</code>等，都是class，创建后便是对象，继承<strong>NSObject</strong>。</li>
</ul>
<p>OC中提供了<code>NSValue</code>、<code>NSNumber</code>来封装C语言的基本类型，这样我们就可以让他们具有面向对象的特征了。</p>
<ul>
<li><strong>id：</strong><code>id</code>是指向Objective-C对象的指针，等价于C语言中的<code>void*</code>，可以映射任何对象指针指向他，或者映射它指向其他的对象。常见的id类型就是类的delegate属性。</li>
</ul>
<p><strong>集合NSSet和数组NSArray区别：</strong></p>
<ul>
<li>都是存储不同的对象的地址；</li>
<li>但是NSArray是有序的集合，NSSet是无序的集合，它们俩可以互相转换。</li>
<li>NSSet会自动删除重复元素。</li>
<li>集合是一种哈希表，运用散列算法，查找集合中的元素比数组速度更快，但是它没有顺序。</li>
</ul>
<p><strong>③ 构造类型</strong></p>
<p>**构造类型包括：**结构体、联合体</p>
<ul>
<li><strong>结构体：</strong><code>struct</code>，将多个基本数据类型的变量组合成一个整体。结构体中访问内部成员用点运算符访问。</li>
<li><strong>联合体(共用体)：</strong><code>union</code>，有些类似结构体<code>struct</code>的一种数据结构，联合体(<code>union</code>)和结构体(<code>struct</code>)同样可以包含很多种数据类型和变量。</li>
</ul>
<p><strong>结构体和联合体的区别：</strong></p>
<ul>
<li>
<p>结构体(<code>struct</code>)中所有变量是“共存”的，同一时刻每个成员都有值，其<code>sizeof</code>为所以成员的和。</p>
<p>**优点：**是“有容乃大”，全面；</p>
<p>**缺点：**是struct内存空间的分配是粗放的，不管用不用，全</p>
</li>
</ul>
<p><strong>分配，会造成内存浪费。</strong></p>
<ul>
<li>
<p>联合体(<code>union</code>)中各变量是“互斥”的，同一时刻只有一个成员有值，其<code>sizeof</code>为最长成员的<code>sizeof</code>。</p>
<p>**优点：**是内存使用更为精细灵活，也节省了内存空间。</p>
<p>**缺点：**就是不够“包容”，修改其中一个成员时会覆盖原来的成员值；</p>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
